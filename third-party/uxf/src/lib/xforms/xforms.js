/*
 * Copyright (c) 2008-2009 Backplane Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*global NamespaceManager, UX, document, UX.getProxyNode*/

/**
 * Retrieves the model to which the node <i>oNode</i> is bound. This is based
 * on the presence of model or bind attributes, or on context information gained
 * from the the node's position in the document.
 * 
 * @param {Object}
 *            oNode, node whose model is to be resolved.
 * @returns Node that corresponds to the appropriate model for oNode's binding.
 */

function getModelFor(oNode) {
	// If the node is null, this function is likely to have recursed up to the
	// document root and beyond, without encountering any specific directions 
	// for model resolution. return the document's
	// default model.
	if (!oNode || oNode.nodeType === 9 /* DOCUMENT_TYPE */ ) {
		// TODO: The default model may be the implicit model. Implicit models
		// have not been implemented yet.
		// If the implicit model is generated by inserting a model element into
		// the DOM, then this function
		// will work out-of-the-box. Otherwise, this first branch will need to
		// be rewritten to use whatever
		// factory or repository exists for fetching potentially implicit
		// models.
		// Even if the above mechanism is used for generating the implicit
		// model, if this function is called
		// before the implicit model is otherwise generated then it must be
		// generated by this branch.
		if (!document.defaultModel) {
			var models = NamespaceManager.getElementsByTagNameNS(document, "http://www.w3.org/2002/xforms", "model");
			if (models && models.length > 0) {
				document.defaultModel = DECORATOR.getBehaviour(models[0]);
			}
		}
		return document.defaultModel;
	}
	if (oNode.nodeType === 11 /* FRAGMENT_TYPE */) return null;
	if (oNode.ownerModel) return oNode.ownerModel;
	
	var element = oNode;
	if(element.element) {
		element = element.element;
	} else {
		oNode = DECORATOR.getBehaviour(element);
	}
	
	// if the node has a bind attribute,
	// then resolve model for that bind, copy to self, and return that.
	var bindId = element.getAttribute("bind");

	if (bindId) {
		var bind = FormsProcessor.getBindObject(bindId, oNode);
		if (bind) {
			oNode.ownerModel = getModelFor(bind);
		}
		return oNode.ownerModel;
	}
	
	// If the node has a model attribute return the corresponding node.
	// if the model attribute does not correspond to the ID of a model
	// throw (for now, invoke the debugger.
	var sModelId = element.getAttribute("model");
	if (sModelId) {
		var oMightBeAModel = DECORATOR.getBehaviour(document.getElementById(sModelId));

		if (oMightBeAModel && (oMightBeAModel.xformselement === "model")) {
			oNode.ownerModel = oMightBeAModel;
		} else {
			UX.dispatchEvent(oNode, "xforms-binding-exception", false, true, true);
		}
		return oNode.ownerModel;
	}

	// Only certain nodes within model take the model as context, others
	// follow the normal context resolution pattern.
	if (element.tagName === "bind" && DECORATOR.getBehaviour(element.parentNode).xformselement === "model") {
		oNode.ownerModel = DECORATOR.getBehaviour(element.parentNode);
	} else {
		// In the absence of more specific directions, get the model that is
		// defined for the parentNode, and return that.
		oNode.ownerModel = getModelFor(oNode.parentNode);
	}
	return oNode.ownerModel;
}





var g_DeferredUpdateDepth = 0;



function doUpdate() {
	var models = NamespaceManager.getElementsByTagNameNS(document, "http://www.w3.org/2002/xforms", "model");
	//This may be a forced update, within setfocus or setindex
	// If so, re... events may not work correctly, 
	var storedUpdateDepth = g_DeferredUpdateDepth;
	g_DeferredUpdateDepth = 0;
	for (var i = 0, l = models.length; i < l; i++) {
		var model = DECORATOR.getBehaviour(models[i]);
		// There is a chance that a model has been inserted into the document
		// during the processing of this event, that has not had a chance to 
		// have its behaviour attached. It is not essential that it be caught 
		// in this deferred update phase, as 
		// A) It will be updated when as part of its initialisation
		// B) It can't have been modified during the processing of this event anyway.
		try {
			//only update if it is ready, otherwise, if there are multiple models, 
			// some may rebuild/recalculate etc. before its initial build/calculate, etc.
			if (model.m_bReady) {
				_deferredUpdate(model);
			}
		} catch(e) {
			console.log("Error in deferred update: '" + e + "'.");
		}
	}
	g_DeferredUpdateDepth = storedUpdateDepth;
}

function IncrementDeferredUpdate() {
	++g_DeferredUpdateDepth;
}

function DecrementDeferredUpdate() {
	if (!--g_DeferredUpdateDepth) {
		doUpdate();
	}
}



function XFormsProcessor() {
	this.defaultHandlers = {};
	this.eventStack = [];
	this.hintOffCounter = 0;
	this.supportedVersions = ["1.1"];
	this.halted = false;
	this.navigationList = new NavigableControlList();
}

XFormsProcessor.prototype.find = function(array, value) {
	var i;
	if (!array || !value) {
		return false;
	}
	for (i = 0; i < array.length; i++) {
		if (array[i] === value) {
			return true;
		}
	}

	return false;
};

/**
 Function: getBindObject
 
 bindid - The id of the bind element that is to be returned
 notifyOnException - An EventTarget object that is to be notified in case of exception
 returns - If bindid refers to a bind object, the bind element referenced by bindid, otherwise, null.
 
 An xforms-binding-exception will be raised if there is no element referenced by bindid,
 or if the element with that id is not an xforms bind element.
 
 */
XFormsProcessor.prototype.getBindObject = function(bindid, notifyOnException) {
	var bindObject = null;
	notifyOnException = notifyOnException || document.defaultModel;

	if (bindid) {
		bindObject = document.getElementById(bindid);

		if (!bindObject || !NamespaceManager.compareFullName(bindObject, "bind", "http://www.w3.org/2002/xforms")) {
			//bind not found with this ID
			bindObject = null;
			if (notifyOnException) {
				UX.dispatchEvent(notifyOnException, "xforms-binding-exception", true, false, false);
			}
			this.halted = true;
		}
	}
	return bindObject;
};

XFormsProcessor.prototype.setVersion = function() {
	var defaultModelVersions, i, maxPos;

	if (!this.version) {
		if (!document.defaultModel) {
			if (!getModelFor(null)) {
				return;
			}
		}

		defaultModelVersions = (document.defaultModel.element.getAttribute("version") || "").split(" ");

		// Search for the highest supported version that meets the version requirements
		// of the default model, if any
		maxPos = -1;
		for (i = 0; i < this.supportedVersions.length; i++) {
			if (defaultModelVersions.length === 1 && defaultModelVersions[0].length === 0 || this.find(defaultModelVersions, this.supportedVersions[i])) {
				if (maxPos === -1 || Number(this.supportedVersions[i]) > Number(this.supportedVersions[maxPos])) {
					maxPos = i;
				}
			}
		}

		// If an acceptable version was found, assign it to the processor    
		if (maxPos >= 0) {
			this.version = this.supportedVersions[maxPos];
		}
	}
};

XFormsProcessor.prototype.testModelVersion = function(pModel) {
	var evt, desiredVersion, exceptionMsg;

	// Degenerately fail version check if processor is already halted 
	if (this.halted) {
		return false;
	}

	// If the processor version has not already been selected based on 
	// the default model, then select it now.
	if (!this.version) {
		this.setVersion();
		// If we don't have a version number, then the version of the default model
		// is specified and has an error, so we switch to testing the default model 
		// so the xforms-version-exception is generated on the default model
		if (!this.version) {
			exceptionMsg = "Error in default model version";
			pModel = document.defaultModel || pModel;
		}
	}

	// Get the version attribute value
	desiredVersion = pModel.element.getAttribute("version") || "";

	// If a version preference is not expressed, then this model is
	// relaxed and therefore gets a pass
	if (desiredVersion.length === 0 && this.version) {
		return true;
	}

	// Otherwise, we seek the processor's selected version in the desired version list
	if (this.find(desiredVersion.split(" "), this.version)) {
		return true;
	} else if (this.version) {
		exceptionMsg = "Unsupported version for model " + (pModel.getAttribute("id") || "");
	}

	// Either the processor has no selected version or the processor's selected version 
	// is not among the list of versions required by this model, so xforms-version-exception
	// The event goes to the default model, regardless of which model is in error
	evt = document.createEvent("Events");
	evt.initEvent("xforms-version-exception", true, false);
	evt.context = {
		"error-information": exceptionMsg || ""
	};
	FormsProcessor.dispatchEvent(document.defaultModel || pModel, evt);
	return false;
};

XFormsProcessor.prototype.inheritTrue = function(sMIP, oNode) {
	var retval, nodeProxy, parentProxy;
	nodeProxy = UX.getProxyNode(oNode);
	//Get direct value of this MIP.
	retval = nodeProxy.getMIP(sMIP).value;
	//If there is no direct value then check if any ancestors have one.
	if (retval === undefined && oNode.parentNode) {
		parentProxy = UX.getProxyNode(oNode.parentNode);
		if (parentProxy[sMIP].getValue()) {
			retval = true;
		}
	}
	return retval;
};

XFormsProcessor.prototype.inheritFalse = function(sMIP, oNode) {
	var retval, nodeProxy, parentProxy;
	nodeProxy = UX.getProxyNode(oNode);

	//Get direct value of this MIP.
	retval = nodeProxy.getMIP(sMIP).value;
	//If direct value is not already false, check if any ancestors are false 
	if (retval && oNode.parentNode) {
		parentProxy = UX.getProxyNode(oNode.parentNode);
		if (!parentProxy[sMIP].getValue()) {
			retval = false;
		}
	}
	return retval;
};

XFormsProcessor.prototype.addDefaultEventListener = function(oTarget, sType, oListener) {
	
	if(oTarget.element) oTarget = oTarget.element;

	if (!oTarget.uniqueID) {
		oTarget.uniqueID = "uuid:" + Math.random() + Math.random();
	}

	if (!this.defaultHandlers[oTarget.uniqueID]) {
		this.defaultHandlers[oTarget.uniqueID] = {};
	}

	if (!this.defaultHandlers[oTarget.uniqueID][sType]) {
		this.defaultHandlers[oTarget.uniqueID][sType] = [];
	}

	this.defaultHandlers[oTarget.uniqueID][sType].push(oListener);
};

XFormsProcessor.prototype.removeDefaultEventListener = function(oTarget, sType, oListener) {
	var arrHandlers, i;
	if (this.defaultHandlers[oTarget.uniqueID]) {
		arrHandlers = this.defaultHandlers[oTarget.uniqueID][sType];

		if (arrHandlers) {
			for (i = 0; i < arrHandlers.length; i++) {
				if (arrHandlers[i] === oListener) {
					arrHandlers[i] = null;
				}
			}
		}
	}
};

XFormsProcessor.prototype.addDefaultEventListenerFor = function(target, event, scopeParam, methodName) {
	this.addDefaultEventListener(target, event, {
		scope: scopeParam,
		handleEvent: function() {
			this.scope[methodName]();
		}
	});
};

XFormsProcessor.prototype.dispatchEvent = function(oTarget, oEvent, bForceInlineExecution) {
	if(oTarget.element) oTarget = oTarget.element;
	var eventExecuted = false;
	try {
		IncrementDeferredUpdate();
		this.eventStack.push(oEvent);
		//This is only required for IE.  Conformant browsers despatch events at the correct time without prompting
		eventExecuted = oTarget.dispatchEvent(oEvent);

		if (eventExecuted) {
			this.invokeDefault(oTarget, oEvent);
			this.eventStack.pop();
		}
	} catch(e) {
		// TODO: Need to do something to notify user fatal 
		// error such as xforms-binding-exception
		// alert(e);
		//throw e;
	} finally {
		DecrementDeferredUpdate();
	}
};

XFormsProcessor.prototype.invokeDefault = function(oTarget, e) {
	var arrListeners, i;
	if (this.defaultHandlers[oTarget.uniqueID]) {
		arrListeners = this.defaultHandlers[oTarget.uniqueID][e.type];

		if (arrListeners) {
			for (i = 0; i < arrListeners.length; ++i) {
				if (arrListeners[i]) {
					arrListeners[i].handleEvent(e);
				}
			}
		}
	}
};

XFormsProcessor.prototype.getCurrentEvent = function() {
	var ret = null;
	if (this.eventStack) {
		ret = this.eventStack[this.eventStack.length - 1];
	}
	return ret;
};

XFormsProcessor.prototype.listenForXFormsFocus = function(target, listener) {
	target.element.addEventListener("xforms-focus", {
		handleEvent: function(evt) {
			listener.giveFocus();
		}
	},
	false);
};

(function() {
	//private members related to XFormsProcessor.getElementById 
	var ELEMENT_TYPE = 1,
		chooseDescendentFromList, walkGetElementById, getContainingInnerScope;

	chooseDescendentFromList = function(list, ancestor) {
		var i;
		for (i = 0; i < list.length; ++i) {
			if (ancestor.contains(list[i])) {
				return list[i];
			}
		}
		return null;
	};

	walkGetElementById = function(id, scope) {
		var scopeChild = scope.firstChild,
			returnCandidate = null;
		while (scopeChild && !returnCandidate) {
			if (scopeChild.nodeType === ELEMENT_TYPE && !scopeChild.ignoreOnWalk) {
				if (UX.id(scopeChild) === id) {
					returnCandidate = scopeChild;
				} else {
					returnCandidate = walkGetElementById(id, scopeChild);
				}
			}
			scopeChild = scopeChild.nextSibling;
		}
		return returnCandidate;
	};

	getContainingInnerScope = function(element, outerScope) {
		var candidateScopeContainer = element.parentNode;
		while (candidateScopeContainer.parentNode) {
			if (
				candidateScopeContainer.getAttribute('outerscope') &&
				(!outerScope || outerScope === DECORATOR.getElement(candidateScopeContainer.getAttribute('outerscope')))
			) {
				return candidateScopeContainer;
			}
			candidateScopeContainer = candidateScopeContainer.parentNode;
		}
		return null;
	};

	/**
	 Function: getElementById
	 id: ID used as search term
	 topic: (optional) element used to resolve ambiguities where a scoped ID is concerned
	 
	 Follows the algorithm described here:
	 http://www.w3.org/TR/xforms11/#idref-resolve
	 That is, if the topic is within the same scope as an ambiguous ID, returns the instance
	 of that ID in the same inner scope; otherwise, return the instance that is "exposed"
	 */

	XFormsProcessor.prototype.getElementById = function(id, topic) {
		var returnCandidate, candidateScope;
		returnCandidate = document.getElementById(id);
		if (returnCandidate) {
			candidateScope = getContainingInnerScope(returnCandidate);
			if (candidateScope) {
				var outerScope = DECORATOR.getElement(candidateScope.getAttribute('outerscope'));
				if (topic && outerScope.contains(topic)) {
					returnCandidate = this.getElementByIdWithAncestor(id, getContainingInnerScope(topic, outerScope));
				} else if (!outerScope.exposes(returnCandidate)) {
					returnCandidate = outerScope.getPublicElementById(id);
				}
			}
		}
		return returnCandidate;
	};

	XFormsProcessor.prototype.getElementByIdWithAncestor = function(id, ancestorOrSelf) {
		var returnCandidate, candidateScope;
		if (ancestorOrSelf && UX.id(ancestorOrSelf) === id) {
			//If scope has the requested id, don't bother looking elsewhere, just return it.
			returnCandidate = ancestorOrSelf;
		} else {
			//Use the DOM's built in mechanism for getting an element given an ID
			returnCandidate = document.getElementById(id);
			if (returnCandidate) {

				if (ancestorOrSelf && !ancestorOrSelf.contains(returnCandidate)) {
					//If the element returned by the DOM's id resolver is outside scope, 
					//	it is the wrong one.
					if (UX.isIE) {
						//IE's subversive implementation of getElementsByName returns a list of elements with that id
						//	other browsers just use the name attribute
						returnCandidate = chooseDescendentFromList(document.getElementsByName(id), ancestorOrSelf);
					} else {
						//Unfortunately, now the DOM must be walked, using scope.
						returnCandidate = walkGetElementById(id, ancestorOrSelf);
					}
				}
			}
		}
		return returnCandidate;
	};

} ());

XFormsProcessor.prototype.getProxyNode = function(object) {
	return object.m_proxy && object.m_proxy.m_oNode ? object.m_proxy : null;
};

XFormsProcessor.prototype.getContextNode = function (object) {
	return (object && object.m_context && object.m_context.node) ? object.m_context.node : null;
};

XFormsProcessor.prototype.visitDescendents = function(nodes, visit) {
	var i;
	for (i = 0; i < nodes.length; ++i) {
		this.visitDescendents(nodes[i].childNodes, visit);
		visit(nodes[i]);
	}
};

XFormsProcessor.prototype.refreshDescendents = function(nodes) {
	this.visitDescendents(nodes, function(n) {
		if (typeof n.refresh === "function") {
			n.refresh();
		}
	});
};

XFormsProcessor.prototype.refreshDescendentsForRelevance = function(nodes) {
	this.visitDescendents(nodes, function(n) {
		if (n.dirtyState && typeof n.refresh === "function") {
			n.dirtyState.setDirty("enabled");
			n.refresh();
		}
	});
};

XFormsProcessor.prototype.addToNavigationList = function(control) {
	this.navigationList.addControl(control);
};

XFormsProcessor.prototype.onKeyDown = function(event) {
	if (UX.isHTMLTabKeyEvent(event)) {
		if (UX.isShiftKeyPressed(event)) {
			this.navigateToLastControl();
		} else {
			this.navigateToFirstControl();
		}

		return UX.cancelHTMLEvent(event);
	} else if (UX.isAltKeyPressed(event) && this.navigateToKeyedControl(UX.getHTMLKeyEventCode(event))) {
		return UX.cancelHTMLEvent(event);
	}

	return true;
};

XFormsProcessor.prototype.navigateToFirstControl = function() {
	this.focusControl(this.navigationList.getFirstControl());
};

XFormsProcessor.prototype.navigateToLastControl = function() {
	this.focusControl(this.navigationList.getLastControl());
};

XFormsProcessor.prototype.navigateToNextControl = function(control) {
	this.focusControl(this.navigationList.getNextControl(control) || this.navigationList.getFirstControl());
};

XFormsProcessor.prototype.navigateToPreviousControl = function(control) {
	this.focusControl(this.navigationList.getPreviousControl(control) || this.navigationList.getLastControl());
};

XFormsProcessor.prototype.navigateToKeyedControl = function(key) {
	var control = this.navigationList.getControlByAccessKey(key);
	if (control) {
		this.focusControl(control);
		return true;
	}

	return false;
};

XFormsProcessor.prototype.focusControl = function(control) {
	if (control) {
		if (typeof control.giveFocus === 'function') {
			control.giveFocus();
		} else {
			control.focus();
		}
	}
};

XFormsProcessor.prototype.fn = {};

XFormsProcessor.prototype.extend = function(extension) {
	for (var name in extension) {
		if (extension.hasOwnProperty(name)) {
			this.fn[name] = extension[name];
			FunctionCallExpr.prototype.xpathfunctions[name] = function(context) {
				return FormsProcessor.callExtension(name, context, this.args);
			};
		}
	}
};

XFormsProcessor.prototype.callExtension = function(name, context, args) {
	var i, marshalledArgs = [];

	try {
		for (i = 0; i < args.length; ++i) {
			marshalledArgs.push(args[i].evaluate(context).stringValue());
		}

		return new StringValue(this.fn[name].apply(null, marshalledArgs));
	} catch(e) {
		this.dispatchExceptionEvent(context);
	}

	return new StringValue('');
};

XFormsProcessor.prototype.dispatchExceptionEvent = function(context) {
	if (NamespaceManager.compareFullName(context.resolverElement, 'bind', 'http://www.w3.org/2002/xforms')) {
		UX.dispatchEvent(context.currentModel || document.defaultModel, 'xforms-compute-exception', true, false, false);
	} else {
		UX.dispatchEvent(context.resolverElement, 'xforms-binding-exception', true, false, false);
	}
};

var FormsProcessor = new XFormsProcessor();

//override of DOM flushEventQueue, to ensure that deferred update, 
//  and appropriate default invocation are respected.
var flushEventQueue = function() {
	var oPendingEvent = g_pendingEvents.pop();
	while (oPendingEvent) {
		FormsProcessor.dispatchEvent(oPendingEvent.target, oPendingEvent.evt, true);
		oPendingEvent = g_pendingEvents.pop();
	}
};
